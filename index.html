<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pet Snippet Editor</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://unpkg.com/@ltd/j-toml@1.38.0/index.js"></script>
  <script src="https://unpkg.com/fuse.js@6.6.2/dist/fuse.basic.min.js"></script>
  <script src="utils/toml-parser.js"></script>
  <script src="utils/var-parser.js"></script>
  <script src="utils/state-persistence.js"></script>
  <script src="utils/drag-reorder.js"></script>
  <script src="components/file-list.js"></script>
  <script src="components/snippet-list.js"></script>
  <script src="components/snippet-item.js"></script>
  <script src="components/settings-dialog.js"></script>
</head>
<body>
  <div class="app-container">
    <aside class="sidebar" id="sidebar">
      <file-list></file-list>
    </aside>
    <div class="sidebar-resize-handle" id="sidebar-resize"></div>
    <main class="main">
      <header class="header">
        <div class="header-left">
          <button id="sidebar-toggle" class="btn-icon" title="Toggle file list">
            <span class="sidebar-toggle-icon">☰</span>
          </button>
          <h1 id="file-name-display">Pet Snippet Editor</h1>
        </div>
        <div style="display: flex; align-items: center; gap: 0.75rem;">
          <div class="theme-toggle">
            <button id="theme-light">Light</button>
            <button id="theme-auto" class="active">Auto</button>
            <button id="theme-dark">Dark</button>
          </div>
          <button id="settings-btn" class="btn-icon" title="Settings">
            <span style="font-size: 1.25rem;">⚙</span>
          </button>
        </div>
      </header>
      <div class="snippet-list-container">
        <snippet-list></snippet-list>
      </div>
    </main>
  </div>

  <input type="file" id="file-input" accept=".toml" style="display: none;" multiple>

  <script type="module">
    // Theme management
    const themeState = {
      mode: 'auto', // 'light', 'dark', 'auto'
      mediaQuery: null
    };

    function initTheme() {
      // Load saved theme preference
      const savedTheme = localStorage.getItem('theme-mode') || 'auto';
      themeState.mode = savedTheme;

      // Setup media query for auto mode
      themeState.mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      themeState.mediaQuery.addEventListener('change', updateTheme);

      // Apply theme
      updateTheme();
      updateThemeButtons();
    }

    function updateTheme() {
      const html = document.documentElement;

      if (themeState.mode === 'light') {
        html.removeAttribute('data-theme');
      } else if (themeState.mode === 'dark') {
        html.setAttribute('data-theme', 'dark');
      } else { // auto
        if (themeState.mediaQuery.matches) {
          html.setAttribute('data-theme', 'dark');
        } else {
          html.removeAttribute('data-theme');
        }
      }
    }

    function setTheme(mode) {
      themeState.mode = mode;
      localStorage.setItem('theme-mode', mode);
      updateTheme();
      updateThemeButtons();
    }

    // Expose setTheme globally for settings dialog
    window.setTheme = setTheme;

    function updateThemeButtons() {
      document.querySelectorAll('.theme-toggle button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(`theme-${themeState.mode}`).classList.add('active');
    }

    // Global state
    const appState = {
      openFiles: [],
      selectedFileIndex: -1
    };

    // Load saved state from localStorage on app initialization
    function initializeApp() {
      const savedState = window.StatePersistence.loadState();
      if (savedState) {
        appState.openFiles = savedState.openFiles;
        appState.selectedFileIndex = savedState.selectedFileIndex;

        // Update UI to reflect loaded state
        updateFileList();
        updateHeader();
        updateSnippetList();
      }
    }

    // Global helper functions
    window.markFileDirty = function() {
      if (appState.selectedFileIndex >= 0 && appState.selectedFileIndex < appState.openFiles.length) {
        const file = appState.openFiles[appState.selectedFileIndex];
        file.dirty = true;
        updateFileList();
        window.StatePersistence.saveState(appState);
      }
    };

    window.updateSnippetsInFile = function(snippets) {
      if (appState.selectedFileIndex >= 0 && appState.selectedFileIndex < appState.openFiles.length) {
        const file = appState.openFiles[appState.selectedFileIndex];
        file.parsed.snippets = snippets;
        file.dirty = true;
        updateFileList();
        updateSnippetList();
        window.StatePersistence.saveState(appState);
      }
    };

    // File operations
    function handleFileUpload(event) {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const fileObj = {
            name: file.name,
            content: e.target.result,
            parsed: null
          };

          // Parse TOML
          try {
            fileObj.parsed = window.TomlParser.parse(e.target.result);
          } catch (err) {
            console.error('Failed to parse TOML:', err);
            alert(`Failed to parse ${file.name}: ${err.message}`);
          }

          appState.openFiles.push(fileObj);
          updateFileList();

          // Auto-select first file if none selected
          if (appState.selectedFileIndex === -1) {
            selectFile(appState.openFiles.length - 1);
          }

          // Save state after adding file
          window.StatePersistence.saveState(appState);
        };
        reader.readAsText(file);
      });

      // Reset input
      event.target.value = '';
    }

    function createNewFile() {
      let counter = 1;
      let fileName = 'new.toml';

      // Check for name conflicts
      while (appState.openFiles.some(f => f.name === fileName)) {
        fileName = `new-${counter}.toml`;
        counter++;
      }

      const content = '[[snippets]]\n';
      const fileObj = {
        name: fileName,
        content: content,
        parsed: null
      };

      // Parse TOML
      try {
        fileObj.parsed = window.TomlParser.parse(content);
      } catch (err) {
        console.error('Failed to parse TOML:', err);
      }

      appState.openFiles.push(fileObj);
      updateFileList();
      selectFile(appState.openFiles.length - 1);
      window.StatePersistence.saveState(appState);
    }

    function selectFile(index) {
      appState.selectedFileIndex = index;
      updateFileList();
      updateHeader();
      updateSnippetList();
      window.StatePersistence.saveState(appState);
    }

    function closeFile(index) {
      appState.openFiles.splice(index, 1);

      // Adjust selected index
      if (appState.selectedFileIndex >= appState.openFiles.length) {
        appState.selectedFileIndex = appState.openFiles.length - 1;
      }

      updateFileList();
      updateHeader();
      updateSnippetList();
      window.StatePersistence.saveState(appState);
    }

    function renameFile(index, newName) {
      if (index < 0 || index >= appState.openFiles.length) return;
      if (!newName || !newName.trim()) return;

      // Check for name conflicts
      const nameExists = appState.openFiles.some((f, i) => i !== index && f.name === newName);
      if (nameExists) {
        alert(`A file named "${newName}" already exists.`);
        updateFileList();
        return;
      }

      appState.openFiles[index].name = newName;
      updateFileList();
      updateHeader();
      window.StatePersistence.saveState(appState);
    }

    function updateUI() {
      updateFileList();
      updateHeader();
      updateSnippetList();
    }

    function updateFileList() {
      const fileListElement = document.querySelector('file-list');
      if (fileListElement) {
        fileListElement.render(appState.openFiles, appState.selectedFileIndex);
      }
    }

    function updateHeader() {
      const headerElement = document.getElementById('file-name-display');
      if (appState.selectedFileIndex >= 0 && appState.selectedFileIndex < appState.openFiles.length) {
        headerElement.textContent = appState.openFiles[appState.selectedFileIndex].name;
      } else {
        headerElement.textContent = 'Pet Snippet Editor';
      }
    }

    function updateSnippetList() {
      const snippetListElement = document.querySelector('snippet-list');
      if (snippetListElement) {
        const file = appState.selectedFileIndex >= 0 ? appState.openFiles[appState.selectedFileIndex] : null;
        const snippets = file?.parsed?.snippets || [];
        snippetListElement.render(snippets);
      }
    }

    function saveFile(index) {
      if (index < 0 || index >= appState.openFiles.length) return;

      const file = appState.openFiles[index];

      try {
        // Convert parsed object back to TOML
        const tomlContent = window.TomlParser.stringify(file.parsed);

        // Create blob and download
        const blob = new Blob([tomlContent], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        // Clear dirty flag
        file.dirty = false;
        updateFileList();
        window.StatePersistence.saveState(appState);
      } catch (err) {
        console.error('Failed to save file:', err);
        alert(`Failed to save ${file.name}: ${err.message}`);
      }
    }

    // Copy snippet to another file
    function copySnippetToFile(snippet, targetFileIndex) {
      if (targetFileIndex < 0 || targetFileIndex >= appState.openFiles.length) return;

      const targetFile = appState.openFiles[targetFileIndex];
      if (!targetFile.parsed.snippets) {
        targetFile.parsed.snippets = [];
      }

      // Create a deep copy of the snippet
      const snippetCopy = JSON.parse(JSON.stringify(snippet));
      targetFile.parsed.snippets.push(snippetCopy);
      targetFile.dirty = true;

      updateFileList();
      // If copying to current file, update snippet list
      if (targetFileIndex === appState.selectedFileIndex) {
        updateSnippetList();
      }
      window.StatePersistence.saveState(appState);
    }

    // Copy multiple snippets to another file
    function copySnippetsToFile(snippets, targetFileIndex) {
      if (targetFileIndex < 0 || targetFileIndex >= appState.openFiles.length) return;

      const targetFile = appState.openFiles[targetFileIndex];
      if (!targetFile.parsed.snippets) {
        targetFile.parsed.snippets = [];
      }

      // Create deep copies of all snippets
      snippets.forEach(snippet => {
        const snippetCopy = JSON.parse(JSON.stringify(snippet));
        targetFile.parsed.snippets.push(snippetCopy);
      });
      targetFile.dirty = true;

      updateFileList();
      // If copying to current file, update snippet list
      if (targetFileIndex === appState.selectedFileIndex) {
        updateSnippetList();
      }
      window.StatePersistence.saveState(appState);
    }

    // Get open files for copy dialog
    function getOpenFiles() {
      return appState.openFiles;
    }

    // Expose functions to window for component access
    window.createNewFile = createNewFile;
    window.selectFile = selectFile;
    window.closeFile = closeFile;
    window.renameFile = renameFile;
    window.saveFile = saveFile;
    window.copySnippetToFile = copySnippetToFile;
    window.copySnippetsToFile = copySnippetsToFile;
    window.getOpenFiles = getOpenFiles;
    window.updateUI = updateUI;
    window.appState = appState;

    // Setup file input listener
    document.getElementById('file-input').addEventListener('change', handleFileUpload);

    // Setup theme toggle listeners
    document.getElementById('theme-light').addEventListener('click', () => setTheme('light'));
    document.getElementById('theme-auto').addEventListener('click', () => setTheme('auto'));
    document.getElementById('theme-dark').addEventListener('click', () => setTheme('dark'));

    // Setup settings button listener
    document.getElementById('settings-btn').addEventListener('click', () => {
      const dialog = document.createElement('settings-dialog');
      document.body.appendChild(dialog);
      dialog.classList.add('visible');
      dialog.show();
    });

    // Sidebar toggle and resize functionality
    function initSidebarToggle() {
      const sidebar = document.getElementById('sidebar');
      const toggleBtn = document.getElementById('sidebar-toggle');
      const resizeHandle = document.getElementById('sidebar-resize');

      // Load saved sidebar state
      const savedWidth = localStorage.getItem('sidebar-width');
      if (savedWidth) {
        sidebar.style.width = savedWidth + 'px';
        document.documentElement.style.setProperty('--sidebar-width', savedWidth + 'px');
      }

      const sidebarCollapsed = localStorage.getItem('sidebar-collapsed') === 'true';
      if (sidebarCollapsed) {
        sidebar.classList.add('collapsed');
      }

      toggleBtn.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
        const isCollapsed = sidebar.classList.contains('collapsed');
        localStorage.setItem('sidebar-collapsed', isCollapsed);
      });

      // Resize functionality
      let isResizing = false;
      let startX = 0;
      let startWidth = 0;

      resizeHandle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = sidebar.offsetWidth;
        sidebar.classList.add('resizing');
        resizeHandle.classList.add('resizing');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const diff = e.clientX - startX;
        const newWidth = startWidth + diff;

        // Enforce min and max width
        const minWidth = 150;
        const maxWidth = 600;
        const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

        sidebar.style.width = clampedWidth + 'px';
        document.documentElement.style.setProperty('--sidebar-width', clampedWidth + 'px');
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          sidebar.classList.remove('resizing');
          resizeHandle.classList.remove('resizing');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';

          // Save the new width
          localStorage.setItem('sidebar-width', sidebar.offsetWidth);
        }
      });
    }

    // Initialize theme first (to avoid flash of unstyled content)
    initTheme();

    // Initialize variable parser
    if (window.VarParser && window.VarParser.init) {
      window.VarParser.init();
    }

    // Initialize sidebar toggle
    initSidebarToggle();

    // Initialize app and load saved state
    initializeApp();
  </script>
</body>
</html>
